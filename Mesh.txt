ESP-NOW:
	mesh connection, advertisement of nodes, root election, adding new node, deleting dead node, re-consttructure of mesh, passing control
WIFI:
	root propagates and updates mesh topology, application data
- Node comes alive, WPS button pressed (maybe webpage for first ESP board to configure wifi connection and generate MESH key) and will listen and broadcast through ESP-NOW to search MESH
- Nodes will advertise them self, will advertise their neigbours they see and RSSI how good they see them
- Every node has a whole table of all the |MAC addresses  | F(RSSI * neighbors) + access point RSSI
- when we decide we have the whole table and we can start root election???
- Thus every node has idea of the probably best candidate for root, root election
- With every new node connected to the mesh, topolgy is updated and propagated, root node waits for some time(with each level=depth time interval gets bigger)  for child nodes to anounce their children and root will decide which child node will claim new added node as his child 
- all nodes are connected to the mesh and knows whole topology (i.e. JSON)
- passing of control to new node to become root (better router RSSI)
- Some routing: each node has probably whole routing table with |MAC | Next hop MAC| of all the nodes, if node cant find record it will broadcast it.

Mesh Controll :
1. Wireless network establishment - WPS settings, Node Broadcast, collect all MAC addresses of all the nodes and propagate your local table of neighbors. Converge when all the nodes have the same count of MAC addresses.
2. Converged -> Root election - based on F() of each node, every node has whole table thus every node knows who is the best Root node, when in Connected mode F() is RSSI to the router? or we can separete these two roles and have Root node and Access Point node
3. Upstream conn. establishment i.e.:
    if: root seen & f(RSSI < X); connect to root  - some Threshold
    unicast to known nodes, except upstream nodes (containig path cost f())
    elseif: root not seen, do:
        decide based on cumulative RSSI (path cost f()) of each advertised path.
        unicast to known nodes, except upstream nodes (containig path cost f())
4. Detect network changes (dead node / new node)
Dead node:
timer - heartbeat from nodes times out
scan network, announce dead node
            root/upstream available
            Better option available (upholds #2 rules)
New node:
scan network
do #2 rules

send broadcast update to neighbors to update their [MAC, Next-Hop] table (either add or remove) - similar in step 1 collection of MAC addresses

[5. Demo APP - *traffic handling  
    generate sensor traffic
        dst MAC ???  
        send

Traffic handling:
1. * define frame types and structure
2. Application:
    check sensor, timeout
        if value < X:
            do action
            send message to perform action
    Receive mesaage to perfom action:
        do action
]

Work actions:
1. traffic generation
2. receive traffic, check downstream table, if dst is in downstream t. send to downstream node  
        else send upstream

Required Data structures:
    List of all the nodes: |MAC addresses F(RSSI * neighbors) + access point RSSI
    Topology: MAC | children
    Routing table: MAC address table of all the nodes, Next-Hop MAC - either Downstream nodes that advertised this new MAC, otherwise  Parent to know to which socket() send the packet
    Frame structure

